<agent-task mode="planning">
    <objective>
        # Esperanza (Minishop): Add a rollback + user query prepend scenario.

        ## Goals
        - Add "another scenario" to `scripts/esperanza/minishop.py`.
        - This scenario uses **rollback + user query prepend** together to validate a **query change** case by "deleting (rollback)" a past transaction and inserting a "correction query (prepend)" at the same point in time.

        ## Requirements / constraints
        - The input SQL for `db_state_change prepend=gid,sqlfile` must use **DML only**. (Avoid DDL/USE/DELIMITER/etc.)
        - **Do not use session variables (@o1, etc.)** in the prepend SQL. Those variables may not be reproduced in the replay context.
        - The prepend SQL must be accessible relative to the `db_state_change` execution cwd (= session_path).
          - Safest approach: have `minishop.py` create the prepend SQL file under session_path.

        ## Implementation scope (recommended)
        - `scripts/esperanza/minishop.py`: add a case switch (e.g., `--case rollback`, `--case rollback_prepend`) or add a second execution path
        - (Optional) `scripts/esperanza/minishop/*.sql`: strengthen verification queries (validate refund amount, etc.)
    </objective>

    <scenario name="minishop-rollback-prepend">
        <human-readable-description>
            # Minishop Append Case: Correct a fraudulent refund into a "partial refund" (rollback + prepend)

            ## Overview
            - Run the base scenario the same as the existing `minishop`. (Leave refund_item as a "fraudulent refund".)
            - In the retroactive operation phase:
              1) Roll back the `refund_item(@o1)` transaction.
              2) Prepend a bundle of DML queries that implements a "partial refund" at the same GID.
            - As a result, delete + replace the past `refund_item` to create a "query change" case.

            ## Base execution sequence (same as existing minishop)
            - Before running, make sure to run `SET autocommit = 0;` in the session.
            - Wrap every procedure call with `START TRANSACTION; ... COMMIT;`.
            1) ADD_ITEM(1, 'cola', 100, 10)
            2) ADD_ITEM(2, 'chips', 200, 5)
            3) RESTOCK_ITEM(1, 5)         -- item1 stock: 15
            4) BUY_ITEM(1, 3, @o1)        -- item1 stock: 12, order total: 300
            5) BUY_ITEM(2, 1, @o2)        -- item2 stock: 4
            6) REFUND_ITEM(@o1)           -- item1 stock: 15 (fraud, incorrect full refund)
            7) RESTOCK_ITEM(2, 2)         -- item2 stock: 6 (independent)
            8) BUY_ITEM(1, 2, @o3)        -- item1 stock: 13 (after the refund)

            ## Retroactive change (core)
            - Goal: correct the "full refund (+3, amount=300)" of `refund_item(@o1)` into a "partial refund (+1, amount=100)".
            - Implementation: apply rollback + prepend to the **same GID**.

            ### 1) Find the rollback target GID
            - Find the GID of the `refund_item` transaction via `state_log_viewer -i <path>/benchbase.ultstatelog -Q -v`.
            - Or use `find_gid_by_query()` in `minishop.py` with needles such as `refund_item`, `refunds`, `REFUNDED`.

            ### 2) Create the prepend user-query SQL file (DML only)
            - Create the file under session_path (= read by relative path from db_state_change cwd).
            - Do not use session variables (@o1); fix the order_id via a subquery instead.

            Example: `prepend_partial_refund.sql`
            - Target the "earliest order for item_id=1 (= @o1)".
            - Partial refund policy:
              - orders.status = 'REFUNDED'
              - items.id=1 stock += 1
              - refunds.amount = 100

            ```sql
            UPDATE orders
            SET status = 'REFUNDED'
            WHERE order_id = (SELECT MIN(order_id) FROM orders WHERE item_id = 1);

            UPDATE items
            SET stock = stock + 1
            WHERE id = 1;

            INSERT INTO refunds(order_id, amount)
            VALUES ((SELECT MIN(order_id) FROM orders WHERE item_id = 1), 100);
            ```

            ### 3) Run db_state_change (prepare -> replay)
            - Prepare phase (specify rollback + prepend together):
              - `db_state_change ultraverse.json rollback=<refund_gid>:prepend=<refund_gid>,prepend_partial_refund.sql`
            - Replay phase:
              - `db_state_change ultraverse.json replay`

            ## Expected results (final state after correction)
            - items.id=1 stock: 11
              - 10 + restock(5) - buy(3) + partial_refund(1) - buy(2) = 11
            - items.id=2 stock: 6 (expect item2-related transactions to be skipped row-wise)
            - orders(@o1).status: REFUNDED
              - Identify @o1 by pinning it to `MIN(order_id) WHERE item_id=1`.
            - refunds: 1 record for @o1 + amount=100

            ## Recommended key columns
            - items.id
            - orders.order_id

            ## Row-wise skip validation (optional)
            - `replayGidCount` in the prepare report should be small.
              - Ideally, only transactions that affect item1 after the refund (e.g., BUY_ITEM(1,2)) are replayed.
        </human-readable-description>

        <table-definition lang="sql">
            CREATE TABLE items (
                id INT PRIMARY KEY,
                name VARCHAR(64) NOT NULL,
                price INT NOT NULL,
                stock INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB;

            CREATE TABLE orders (
                order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                item_id INT NOT NULL,
                quantity INT NOT NULL,
                total_price INT NOT NULL,
                status ENUM('PAID','REFUNDED') NOT NULL DEFAULT 'PAID',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT fk_orders_item FOREIGN KEY (item_id) REFERENCES items(id)
            ) ENGINE=InnoDB;

            CREATE TABLE refunds (
                refund_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                order_id BIGINT NOT NULL,
                amount INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT fk_refunds_order FOREIGN KEY (order_id) REFERENCES orders(order_id)
            ) ENGINE=InnoDB;
        </table-definition>

        <db-operation name="add-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE add_item(
                IN p_id INT,
                IN p_name VARCHAR(64),
                IN p_price INT,
                IN p_stock INT
            )
            BEGIN
                INSERT INTO items(id, name, price, stock)
                VALUES (p_id, p_name, p_price, p_stock);
            END;
        </db-operation>
        <db-operation name="restock-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE restock_item(
                IN p_id INT,
                IN p_additional INT
            )
            BEGIN
                UPDATE items
                SET stock = stock + p_additional
                WHERE id = p_id;
            END;
        </db-operation>
        <db-operation name="buy-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE buy_item(
                IN p_item_id INT,
                IN p_qty INT,
                OUT p_order_id BIGINT
            )
            BEGIN
                DECLARE v_price INT;

                SELECT price INTO v_price
                FROM items
                WHERE id = p_item_id;

                INSERT INTO orders(item_id, quantity, total_price, status)
                VALUES (p_item_id, p_qty, v_price * p_qty, 'PAID');

                SET p_order_id = LAST_INSERT_ID();

                UPDATE items
                SET stock = stock - p_qty
                WHERE id = p_item_id;
            END;
        </db-operation>
        <db-operation name="refund-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE refund_item(
                IN p_order_id BIGINT
            )
            BEGIN
                DECLARE v_item_id INT;
                DECLARE v_qty INT;
                DECLARE v_amount INT;

                SELECT item_id, quantity, total_price
                INTO v_item_id, v_qty, v_amount
                FROM orders
                WHERE order_id = p_order_id;

                UPDATE orders
                SET status = 'REFUNDED'
                WHERE order_id = p_order_id;

                UPDATE items
                SET stock = stock + v_qty
                WHERE id = v_item_id;

                INSERT INTO refunds(order_id, amount)
                VALUES (p_order_id, v_amount);
            END;
        </db-operation>

        <scenario-steps lang="sql">
            SET autocommit = 0;

            START TRANSACTION;
            CALL add_item(1, 'cola', 100, 10);
            COMMIT;

            START TRANSACTION;
            CALL add_item(2, 'chips', 200, 5);
            COMMIT;

            START TRANSACTION;
            CALL restock_item(1, 5);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(1, 3, @o1);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(2, 1, @o2);
            COMMIT;

            START TRANSACTION;
            CALL refund_item(@o1);
            COMMIT;

            START TRANSACTION;
            CALL restock_item(2, 2);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(1, 2, @o3);
            COMMIT;
        </scenario-steps>

        <verification>
            -- Verification queries for expected values (after correction)
            SELECT stock FROM items WHERE id = 1;     -- expect 11
            SELECT stock FROM items WHERE id = 2;     -- expect 6

            SELECT status
            FROM orders
            WHERE order_id = (SELECT MIN(order_id) FROM orders WHERE item_id = 1); -- expect REFUNDED

            SELECT COUNT(*)
            FROM refunds
            WHERE order_id = (SELECT MIN(order_id) FROM orders WHERE item_id = 1); -- expect 1

            SELECT amount
            FROM refunds
            WHERE order_id = (SELECT MIN(order_id) FROM orders WHERE item_id = 1); -- expect 100
        </verification>
    </scenario>
</agent-task>

