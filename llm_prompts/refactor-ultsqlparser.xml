<agent-task mode="planning">
    <objective>
        # ultsqlparser를 리팩터링한다

        ## 1. 소스 코드 분리
        - 실제 SQL을 파싱하고, syntax-tree를 만드는 부분과, C interop를 통해 기능을 제공하는 외부 exported interface를 별도 파일로 분리합니다.

        ## 2. 퍼블릭 인터페이스 정의
        - 아래 코드와 같은 C Interop 인터페이스를 정의합니다.
        - 지금은 존재하지만, 아래에 없는 기능들은 **삭제되어야 합니다.**
            - 구 버전의 TiDB 파서에서 지원하지 않는 문법에 대한 HACK이 대부분입니다. 현재는 TiDB 파서가 충분히 발전했으므로, 이러한 HACK들은 제거합니다.

        ## 2-1. 퍼블릭 인터페이스의 breaking change에 대응하기
        - 퍼블릭 인터페이스에 대해 breaking change가 발생하므로, ultsqlparser를 사용하는 C++ 상위 모듈들에서 이를 대응시킵니다.

        ## 3. 코드 정리
        - 너무 난잡한 코드 구조를 개선합니다.
        - 불필요한 주석, 디버깅 코드 등을 제거합니다.
        - Go 언어의 모범 사례에 맞게 코드를 정리합니다.
        - GoDoc을 추가하여 함수와 타입의 역할을 명확히 합니다.

        ## 4. 테스트 코드 작성
        - tests/sqlparser-test.cpp와 비슷한 동작을 하는 테스트 코드를 Go 패키지 내에 작성합니다.

    </objective>
    <code lang="text/x-pseudocode; variant=swift" name="ultparserlib.go (였으면 하는 것)">
        // ultsqlparser.go

        /// # ABOUT PARSER INSTANCES
        /// - thread-safe 하지 않습니다. 각 스레드마다 별도 파서 인스턴스를 생성하여 사용하고, 스레드 간 혼용하지 마십시오.
        // 실제론 Pointer이지만 Handle처럼 다룬다
        typealias ult_sql_parser_t = Int // TODO: typeof(pointer)

        /// 새 파서 인스턴스를 생성합니다.
        @convention(c)
        @exported(c)
        func ult_sql_parser_create() -> ult_parser_t? {
            // TODO: tidb.parser.Parser 인스턴스 생성 및 반환
        }

        /// 파서 인스턴스를 해제합니다.
        @convention(c)
        @exported(c)
        func ult_sql_parser_destroy(parser: ult_sql_parser_t?) {
        }

        /// SQL statements를 파싱합니다.
        /// - Parameters:
        ///   - parser: 파서 인스턴스
        ///   - sql: 파싱할 SQL 문자열
        ///   - sql_len: sql 문자열 길이
        ///   - out_stmts: 파싱된 statements를 담을 버퍼 (Protobuf 직렬화된 바이트 배열: ParseResult 메시지)
        /// - Returns: 파싱된 statements의 바이트 길이, 오류 시 음수
        func ult_sql_parse(
            parser: ult_sql_parser_t,
            sql: UnsafePointer<CChar>?,
            sql_len: Int,
            out_stmts: UnsafeMutablePointer<CChar>?
        ) -> Int

        /// 같은 쿼리인지 비교하기 위해 SQL Statement Tree에 대한 hash 값을 계산합니다.
        /// - Parameters:
        ///   - parser: 파서 인스턴스
        ///   - sql: 해시를 계산할 SQL 문자열
        ///   - sql_len: sql 문자열 길이
        ///   - out_hash: 계산된 해시 값을 담을 버퍼 (20-byte SHA1 hash)
        /// - Returns: 해시 값의 바이트 길이 (20), 오류 시 음수
        func ult_query_hash(
            parser: ult_sql_parser_t,
            sql: UnsafePointer<CChar>?,
            sql_len: Int,
            out_hash: UnsafeMutablePointer<CChar>?
        ) -> Int

        /// SQL statements를 파싱하고, JSON 형식으로 반환합니다. 디버깅 목적으로만 사용하십시오!!
        func ult_parse_jsonify(
            parser: ult_sql_parser_t,
            sql: UnsafePointer<CChar>?,
            sql_len: Int,
            out_json: UnsafeMutablePointer<CChar>?
        ) -> Int
    </code>
    <note>
        - 실제 구현은 @codex-delegate 스킬을 사용하여 OpenAI Codex에게 위임하십시오.
        - 전체 태스크를 위임하지 말고, 한단계 한단계씩 나누어 위임하십시오.
        - 각 단계별로 구현된 코드를 검토하고, 필요한 경우 수정 및 보완 요청을 Codex에게 전하십시오.
    </note>
</agent-task>