<agent-task mode="planning">
    <objective>
        # Esperanza (Minishop): rollback + user query prepend 시나리오를 추가한다.

        ## 목표
        - `scripts/esperanza/minishop.py`에 "어나더 시나리오"를 추가한다.
        - 이번 시나리오는 **rollback + user query prepend**를 함께 사용해, 과거의 트랜잭션을 “삭제(rollback)”하고 같은 시점에 “교정 쿼리(prepend)”를 삽입하여 **쿼리 변경(change)** 케이스를 검증한다.

        ## 요구사항 / 제약
        - `db_state_change prepend=gid,sqlfile`의 입력 SQL은 **DML만** 사용한다. (DDL/USE/DELIMITER 등은 피한다)
        - prepend SQL에서 **세션 변수(@o1 등)를 사용하지 않는다**. replay 컨텍스트에서 해당 변수가 재현되지 않을 수 있다.
        - prepend SQL은 `db_state_change` 실행 cwd(= session_path) 기준으로 접근 가능해야 한다.
          - 가장 안전한 방법: `minishop.py`가 session_path 아래에 prepend SQL 파일을 생성한다.

        ## 구현 범위(권장)
        - `scripts/esperanza/minishop.py`: 케이스 분기(예: `--case rollback`, `--case rollback_prepend`) 또는 두 번째 실행 경로 추가
        - (선택) `scripts/esperanza/minishop/*.sql`: verify 쿼리 보강(환불 금액 검증 등)
    </objective>

    <scenario name="minishop-rollback-prepend">
        <human-readable-description>
            # Minishop Append Case: 부정 환불을 “부분 환불”로 교정한다 (rollback + prepend)

            ## 개요
            - 기본 시나리오는 기존 `minishop`와 동일하게 실행한다. (refund_item은 “부정 환불”로 남겨둔다)
            - Retroactive operation 단계에서:
              1) `refund_item(@o1)` 트랜잭션을 rollback 한다.
              2) 같은 GID에 “부분 환불”을 구현하는 DML 쿼리 묶음을 prepend 한다.
            - 결과적으로 과거의 `refund_item`을 **삭제 + 교체**하여 “쿼리 변경” 케이스를 만든다.

            ## 기본 실행 시퀀스 (기존 minishop와 동일)
            - 실행 전 세션에서 반드시 `SET autocommit = 0;` 실행
            - 모든 프로시저 호출은 `START TRANSACTION; ... COMMIT;`으로 감싼다.
            1) ADD_ITEM(1, 'cola', 100, 10)
            2) ADD_ITEM(2, 'chips', 200, 5)
            3) RESTOCK_ITEM(1, 5)         -- item1 stock: 15
            4) BUY_ITEM(1, 3, @o1)        -- item1 stock: 12, order total: 300
            5) BUY_ITEM(2, 1, @o2)        -- item2 stock: 4
            6) REFUND_ITEM(@o1)           -- item1 stock: 15 (fraud, 잘못된 전체 환불)
            7) RESTOCK_ITEM(2, 2)         -- item2 stock: 6 (독립)
            8) BUY_ITEM(1, 2, @o3)        -- item1 stock: 13 (refund 이후 기준)

            ## Retroactive 변경(핵심)
            - 목표: `refund_item(@o1)`의 “전체 환불(+3, amount=300)”을 “부분 환불(+1, amount=100)”로 교정한다.
            - 구현: rollback + prepend를 **같은 GID**에 적용한다.

            ### 1) rollback 대상 GID 찾기
            - `state_log_viewer -i <path>/benchbase.ultstatelog -Q -v`로 `refund_item` 트랜잭션의 GID를 찾는다.
            - 또는 `minishop.py`의 `find_gid_by_query()`로 `refund_item`, `refunds`, `REFUNDED` 등의 needle을 써서 찾는다.

            ### 2) prepend용 user query SQL 파일 생성 (DML only)
            - 파일은 session_path 아래에 생성한다(= db_state_change cwd에서 상대경로로 읽힘).
            - SQL은 세션 변수(@o1)를 쓰지 말고, 서브쿼리로 order_id를 고정한다.

            예시: `prepend_partial_refund.sql`
            - “item_id=1의 가장 이른 주문(= @o1)”을 대상으로 한다.
            - 부분 환불 정책:
              - orders.status = 'REFUNDED'
              - items.id=1 stock += 1
              - refunds.amount = 100

            ```sql
            UPDATE orders
            SET status = 'REFUNDED'
            WHERE order_id = (SELECT MIN(order_id) FROM orders WHERE item_id = 1);

            UPDATE items
            SET stock = stock + 1
            WHERE id = 1;

            INSERT INTO refunds(order_id, amount)
            VALUES ((SELECT MIN(order_id) FROM orders WHERE item_id = 1), 100);
            ```

            ### 3) db_state_change 실행 (prepare → replay)
            - prepare 단계(rollback + prepend 동시 지정):
              - `db_state_change ultraverse.json rollback=<refund_gid>:prepend=<refund_gid>,prepend_partial_refund.sql`
            - replay 단계:
              - `db_state_change ultraverse.json replay`

            ## 기대 결과(교정 후 최종 상태)
            - items.id=1 stock: 11
              - 10 + restock(5) - buy(3) + partial_refund(1) - buy(2) = 11
            - items.id=2 stock: 6 (item2 관련 트랜잭션은 row-wise로 스킵되길 기대)
            - orders(@o1).status: REFUNDED
              - @o1 식별은 `MIN(order_id) WHERE item_id=1`로 고정한다.
            - refunds: @o1에 대한 레코드 1개 + amount=100

            ## 키 컬럼 추천
            - items.id
            - orders.order_id

            ## Row-wise skip 검증(선택)
            - prepare report의 `replayGidCount`가 작아야 한다.
              - 이상적으로는 `refund` 이후에 item1에 영향을 주는 트랜잭션(예: BUY_ITEM(1,2))만 replay 된다.
        </human-readable-description>

        <table-definition lang="sql">
            CREATE TABLE items (
                id INT PRIMARY KEY,
                name VARCHAR(64) NOT NULL,
                price INT NOT NULL,
                stock INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB;

            CREATE TABLE orders (
                order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                item_id INT NOT NULL,
                quantity INT NOT NULL,
                total_price INT NOT NULL,
                status ENUM('PAID','REFUNDED') NOT NULL DEFAULT 'PAID',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT fk_orders_item FOREIGN KEY (item_id) REFERENCES items(id)
            ) ENGINE=InnoDB;

            CREATE TABLE refunds (
                refund_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                order_id BIGINT NOT NULL,
                amount INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT fk_refunds_order FOREIGN KEY (order_id) REFERENCES orders(order_id)
            ) ENGINE=InnoDB;
        </table-definition>

        <db-operation name="add-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE add_item(
                IN p_id INT,
                IN p_name VARCHAR(64),
                IN p_price INT,
                IN p_stock INT
            )
            BEGIN
                INSERT INTO items(id, name, price, stock)
                VALUES (p_id, p_name, p_price, p_stock);
            END;
        </db-operation>
        <db-operation name="restock-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE restock_item(
                IN p_id INT,
                IN p_additional INT
            )
            BEGIN
                UPDATE items
                SET stock = stock + p_additional
                WHERE id = p_id;
            END;
        </db-operation>
        <db-operation name="buy-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE buy_item(
                IN p_item_id INT,
                IN p_qty INT,
                OUT p_order_id BIGINT
            )
            BEGIN
                DECLARE v_price INT;

                SELECT price INTO v_price
                FROM items
                WHERE id = p_item_id;

                INSERT INTO orders(item_id, quantity, total_price, status)
                VALUES (p_item_id, p_qty, v_price * p_qty, 'PAID');

                SET p_order_id = LAST_INSERT_ID();

                UPDATE items
                SET stock = stock - p_qty
                WHERE id = p_item_id;
            END;
        </db-operation>
        <db-operation name="refund-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE refund_item(
                IN p_order_id BIGINT
            )
            BEGIN
                DECLARE v_item_id INT;
                DECLARE v_qty INT;
                DECLARE v_amount INT;

                SELECT item_id, quantity, total_price
                INTO v_item_id, v_qty, v_amount
                FROM orders
                WHERE order_id = p_order_id;

                UPDATE orders
                SET status = 'REFUNDED'
                WHERE order_id = p_order_id;

                UPDATE items
                SET stock = stock + v_qty
                WHERE id = v_item_id;

                INSERT INTO refunds(order_id, amount)
                VALUES (p_order_id, v_amount);
            END;
        </db-operation>

        <scenario-steps lang="sql">
            SET autocommit = 0;

            START TRANSACTION;
            CALL add_item(1, 'cola', 100, 10);
            COMMIT;

            START TRANSACTION;
            CALL add_item(2, 'chips', 200, 5);
            COMMIT;

            START TRANSACTION;
            CALL restock_item(1, 5);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(1, 3, @o1);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(2, 1, @o2);
            COMMIT;

            START TRANSACTION;
            CALL refund_item(@o1);
            COMMIT;

            START TRANSACTION;
            CALL restock_item(2, 2);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(1, 2, @o3);
            COMMIT;
        </scenario-steps>

        <verification>
            -- 기대값 확인 쿼리 (교정 후)
            SELECT stock FROM items WHERE id = 1;     -- expect 11
            SELECT stock FROM items WHERE id = 2;     -- expect 6

            SELECT status
            FROM orders
            WHERE order_id = (SELECT MIN(order_id) FROM orders WHERE item_id = 1); -- expect REFUNDED

            SELECT COUNT(*)
            FROM refunds
            WHERE order_id = (SELECT MIN(order_id) FROM orders WHERE item_id = 1); -- expect 1

            SELECT amount
            FROM refunds
            WHERE order_id = (SELECT MIN(order_id) FROM orders WHERE item_id = 1); -- expect 100
        </verification>
    </scenario>
</agent-task>

