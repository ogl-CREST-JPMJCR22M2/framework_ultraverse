<agent-task mode="planning">
    <objective>
        # Esperanza: 작은 통합 테스트 케이스를 만든다.

        ## 목표
        - 기존의 benchbase (java) + ultraverse의 통합 테스트 케이스 대신, 최소한의 상태 전환 기능을 테스트하기 위한 작은 테스트 케이스를 만든다.
          - (esperanza 스크립트 자체가 benchbase 역할을 겸하도록 한다)

        - MySQL 서버를 띄운 뒤, 아래의 시나리오를 실행하고, MySQL 서버를 내린 후 Ultraverse로 실제로 오퍼레이션을 취소하는 시나리오를 수행한다.
        - Ultraverse의 트랜잭션 롤백 기능이 제대로 동작하는지 검증한다.
    </objective>
    <scenario name="minishop">
        <human-readable-description>
            # Minishop: 작은 편의점 네트워크 운영 시나리오

            ## 개요
            - 최소 2개의 상품과 3개의 주문을 만든다.
            - 부정 환불(REFUND_ITEM)을 롤백 대상으로 지정한다.
            - 롤백 후, 재고/주문상태/환불기록이 “환불이 없었던 히스토리”와 동일해지는지 확인한다.
            - 서로 다른 상품(id=2)에 대한 오퍼레이션은 row-wise 클러스터링으로 스킵되기를 기대한다.

            ## 주 오퍼레이션 목록

            - `ADD_ITEM(id, name, price, stock)`   - 새로운 상품 추가
            - `RESTOCK_ITEM(id, additional_stock)` - 기존 상품 재고 보충
            - `BUY_ITEM(id, quantity, &order_id)`  - 고객이 상품 구매
            - `REFUND_ITEM(order_id)`              - 고객이 구매한 상품 환불

            ## 실행 시퀀스 (SQL 호출 순서)
            - 실행 전 세션에서 반드시 `SET autocommit = 0;` 실행
            - 모든 프로시저 호출은 `START TRANSACTION; ... COMMIT;`으로 감싼다.
            1) ADD_ITEM(1, 'cola', 100, 10)
            2) ADD_ITEM(2, 'chips', 200, 5)
            3) RESTOCK_ITEM(1, 5)         -- item1 stock: 15
            4) BUY_ITEM(1, 3, @o1)        -- item1 stock: 12
            5) BUY_ITEM(2, 1, @o2)        -- item2 stock: 4
            6) REFUND_ITEM(@o1)           -- item1 stock: 15 (fraud)
            7) RESTOCK_ITEM(2, 2)         -- item2 stock: 6 (독립)
            8) BUY_ITEM(1, 2, @o3)        -- item1 stock: 13 (refund 이후 기준)

            ## 취소 시나리오
            - 고객이 부정 환불을 했던게 발각되어, 관리자들이 REFUND_ITEM 오퍼레이션을 취소하는 시나리오를 테스트한다.
            - 롤백 후, 환불의 영향이 제거된 상태로 이후 쿼리를 replay한다.

            ## 기대 결과(정상 상태)
            - items.id=1 stock: 10
              (refund이 없었다면 12 → buy_item(2개) → 10)
            - items.id=2 stock: 6 (restock_item(2,2)는 독립 쿼리)
            - orders.order_id=@o1 status: PAID
            - refunds 테이블: order_id=@o1 레코드 없음

            ## 키 컬럼 추천
            - items.id
            - orders.order_id

            ## GID 선정 지침 (rollback 대상)
            - 각 프로시저 콜은 `START TRANSACTION ... COMMIT`으로 감싸서 **GID 1개**로 묶는다.
            - 롤백 대상은 `refund_item(@o1)` 트랜잭션의 단일 GID이다.
            - GID 확인 방법:
              1) `state_log_viewer -i <path>/benchbase.ultstatelog -Q -v` 실행
              2) `refund_item` 트랜잭션에 포함된 SQL 묶음을 찾아 해당 GID 기록
              3) `db_state_change ... rollback=<gid>:replay` 로 실행

        </human-readable-description>
        <table-definition lang="sql">
            CREATE TABLE items (
                id INT PRIMARY KEY,
                name VARCHAR(64) NOT NULL,
                price INT NOT NULL,
                stock INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            ) ENGINE=InnoDB;

            CREATE TABLE orders (
                order_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                item_id INT NOT NULL,
                quantity INT NOT NULL,
                total_price INT NOT NULL,
                status ENUM('PAID','REFUNDED') NOT NULL DEFAULT 'PAID',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT fk_orders_item FOREIGN KEY (item_id) REFERENCES items(id)
            ) ENGINE=InnoDB;

            CREATE TABLE refunds (
                refund_id BIGINT PRIMARY KEY AUTO_INCREMENT,
                order_id BIGINT NOT NULL,
                amount INT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                CONSTRAINT fk_refunds_order FOREIGN KEY (order_id) REFERENCES orders(order_id)
            ) ENGINE=InnoDB;
        </table-definition>
        <db-operation name="add-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE add_item(
                IN p_id INT,
                IN p_name VARCHAR(64),
                IN p_price INT,
                IN p_stock INT
            )
            BEGIN
                INSERT INTO items(id, name, price, stock)
                VALUES (p_id, p_name, p_price, p_stock);
            END;
        </db-operation>
        <db-operation name="restock-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE restock_item(
                IN p_id INT,
                IN p_additional INT
            )
            BEGIN
                UPDATE items
                SET stock = stock + p_additional
                WHERE id = p_id;
            END;
        </db-operation>
        <db-operation name="buy-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE buy_item(
                IN p_item_id INT,
                IN p_qty INT,
                OUT p_order_id BIGINT
            )
            BEGIN
                DECLARE v_price INT;

                SELECT price INTO v_price
                FROM items
                WHERE id = p_item_id;

                INSERT INTO orders(item_id, quantity, total_price, status)
                VALUES (p_item_id, p_qty, v_price * p_qty, 'PAID');

                SET p_order_id = LAST_INSERT_ID();

                UPDATE items
                SET stock = stock - p_qty
                WHERE id = p_item_id;
            END;
        </db-operation>
        <db-operation name="refund-item" lang="sql" hint="mysql-stored-procedure">
            CREATE PROCEDURE refund_item(
                IN p_order_id BIGINT
            )
            BEGIN
                DECLARE v_item_id INT;
                DECLARE v_qty INT;
                DECLARE v_amount INT;

                SELECT item_id, quantity, total_price
                INTO v_item_id, v_qty, v_amount
                FROM orders
                WHERE order_id = p_order_id;

                UPDATE orders
                SET status = 'REFUNDED'
                WHERE order_id = p_order_id;

                UPDATE items
                SET stock = stock + v_qty
                WHERE id = v_item_id;

                INSERT INTO refunds(order_id, amount)
                VALUES (p_order_id, v_amount);
            END;
        </db-operation>
        <scenario-steps lang="sql">
            SET autocommit = 0;

            START TRANSACTION;
            CALL add_item(1, 'cola', 100, 10);
            COMMIT;

            START TRANSACTION;
            CALL add_item(2, 'chips', 200, 5);
            COMMIT;

            START TRANSACTION;
            CALL restock_item(1, 5);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(1, 3, @o1);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(2, 1, @o2);
            COMMIT;

            START TRANSACTION;
            CALL refund_item(@o1);
            COMMIT;

            START TRANSACTION;
            CALL restock_item(2, 2);
            COMMIT;

            START TRANSACTION;
            CALL buy_item(1, 2, @o3);
            COMMIT;
        </scenario-steps>
        <verification>
            -- 기대값 확인 쿼리
            SELECT stock FROM items WHERE id = 1;     -- expect 10
            SELECT stock FROM items WHERE id = 2;     -- expect 6
            SELECT status FROM orders WHERE order_id = @o1; -- expect PAID
            SELECT COUNT(*) FROM refunds WHERE order_id = @o1; -- expect 0
        </verification>
    </scenario>
</agent-task>
