//
// Created by cheesekun on 1/9/23.
//

#include <algorithm>
#include <cctype>
#include <sstream>
#include <utility>
#include <vector>

#include "StringUtil.hpp"

namespace ultraverse::utility {
    std::pair<std::string, std::string> splitTableName(const std::string &input) {
        std::string table;
        std::string column;
        
        auto pos = input.find('.');
        if (pos == std::string::npos) {
            return std::make_pair(input, "");
        }
        
        return std::make_pair(
            input.substr(0, pos),
            input.substr(pos + 1, input.size() - (pos + 1))
        );
    }
    
    std::vector<std::string> split(const std::string &inputStr, char character) {
        std::vector<std::string> list;
    
        std::stringstream sstream(inputStr);
        std::string string;
    
        while (std::getline(sstream, string, character)) {
            list.push_back(string);
        }
    
        return std::move(list);
    }
    
    std::string replaceAll(const std::string &source, const std::string from, const std::string to) {
        auto value = source;
        
        auto pos = 0;
        while (true) {
            pos = value.find(from, pos + 1);
            
            if (pos == std::string::npos) {
                break;
            }
    
            value.replace(pos, from.length(), to);
        }
        
        return std::move(value);
    }
    
    std::string normalizeColumnName(const std::string &columnName) {
        const std::vector<std::pair<std::string, std::string>> replacements {
            { "/* generated by server */", "" },
            { "`", "" },
            { " ", "" },
        };
        
        auto value = columnName;
        
        for (const auto &pair: replacements) {
            value = replaceAll(value, pair.first, pair.second);
        }
        
        return std::move(value);
    }

    std::string toLower(const std::string &source) {
        static const auto tolower = [](unsigned char c) { return std::tolower(c); };
        std::string result(source);

        std::transform(result.begin(), result.end(), result.begin(), tolower);

        return std::move(result);
    }

    namespace {
        std::string trimWhitespace(std::string value) {
            const auto isSpace = [](unsigned char ch) { return std::isspace(ch); };
            value.erase(value.begin(), std::find_if_not(value.begin(), value.end(), isSpace));
            value.erase(std::find_if_not(value.rbegin(), value.rend(), isSpace).base(), value.end());
            return value;
        }
    }

    std::vector<std::vector<std::string>> parseKeyColumnGroups(const std::string &expression) {
        std::vector<std::vector<std::string>> groups;

        std::stringstream sstream(expression);
        std::string groupExpr;

        while (std::getline(sstream, groupExpr, ',')) {
            std::vector<std::string> group;
            std::stringstream groupStream(groupExpr);
            std::string column;

            while (std::getline(groupStream, column, '+')) {
                auto trimmed = trimWhitespace(column);
                if (!trimmed.empty()) {
                    group.push_back(std::move(trimmed));
                }
            }

            if (!group.empty()) {
                groups.push_back(std::move(group));
            }
        }

        return std::move(groups);
    }

    std::vector<std::vector<std::string>> parseKeyColumnGroups(const std::vector<std::string> &expressions) {
        std::vector<std::vector<std::string>> groups;

        for (const auto &expression : expressions) {
            auto parsed = parseKeyColumnGroups(expression);
            for (auto &group : parsed) {
                if (!group.empty()) {
                    groups.push_back(std::move(group));
                }
            }
        }

        return std::move(groups);
    }

    std::vector<std::string> flattenKeyColumnGroups(const std::vector<std::vector<std::string>> &groups) {
        std::vector<std::string> columns;

        for (const auto &group : groups) {
            for (const auto &column : group) {
                if (!column.empty()) {
                    columns.push_back(column);
                }
            }
        }

        return std::move(columns);
    }
}
