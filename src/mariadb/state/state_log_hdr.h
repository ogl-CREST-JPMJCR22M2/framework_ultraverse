#ifndef STATE_LOG_HDR_INCLUDED
#define STATE_LOG_HDR_INCLUDED

#include <cstdint>
#include <cstring>

#include <vector>
#include <string>

#include "darwincompat.hpp"

enum enum_sql_command {
    SQLCOM_SELECT, SQLCOM_CREATE_TABLE, SQLCOM_CREATE_INDEX, SQLCOM_ALTER_TABLE,
    SQLCOM_UPDATE, SQLCOM_INSERT, SQLCOM_INSERT_SELECT,
    SQLCOM_DELETE, SQLCOM_TRUNCATE, SQLCOM_DROP_TABLE, SQLCOM_DROP_INDEX,
    
    SQLCOM_SHOW_DATABASES, SQLCOM_SHOW_TABLES, SQLCOM_SHOW_FIELDS,
    SQLCOM_SHOW_KEYS, SQLCOM_SHOW_VARIABLES, SQLCOM_SHOW_STATUS,
    SQLCOM_SHOW_ENGINE_LOGS, SQLCOM_SHOW_ENGINE_STATUS, SQLCOM_SHOW_ENGINE_MUTEX,
    SQLCOM_SHOW_PROCESSLIST, SQLCOM_SHOW_MASTER_STAT, SQLCOM_SHOW_SLAVE_STAT,
    SQLCOM_SHOW_GRANTS, SQLCOM_SHOW_CREATE, SQLCOM_SHOW_CHARSETS,
    SQLCOM_SHOW_COLLATIONS, SQLCOM_SHOW_CREATE_DB, SQLCOM_SHOW_TABLE_STATUS,
    SQLCOM_SHOW_TRIGGERS,
    
    SQLCOM_LOAD,SQLCOM_SET_OPTION,SQLCOM_LOCK_TABLES,SQLCOM_UNLOCK_TABLES,
    SQLCOM_GRANT,
    SQLCOM_CHANGE_DB, SQLCOM_CREATE_DB, SQLCOM_DROP_DB, SQLCOM_ALTER_DB,
    SQLCOM_REPAIR, SQLCOM_REPLACE, SQLCOM_REPLACE_SELECT,
    SQLCOM_CREATE_FUNCTION, SQLCOM_DROP_FUNCTION,
    SQLCOM_REVOKE,SQLCOM_OPTIMIZE, SQLCOM_CHECK,
    SQLCOM_ASSIGN_TO_KEYCACHE, SQLCOM_PRELOAD_KEYS,
    SQLCOM_FLUSH, SQLCOM_KILL, SQLCOM_ANALYZE,
    SQLCOM_ROLLBACK, SQLCOM_ROLLBACK_TO_SAVEPOINT,
    SQLCOM_COMMIT, SQLCOM_SAVEPOINT, SQLCOM_RELEASE_SAVEPOINT,
    SQLCOM_SLAVE_START, SQLCOM_SLAVE_STOP,
    SQLCOM_BEGIN, SQLCOM_CHANGE_MASTER,
    SQLCOM_RENAME_TABLE,
    SQLCOM_RESET, SQLCOM_PURGE, SQLCOM_PURGE_BEFORE, SQLCOM_SHOW_BINLOGS,
    SQLCOM_SHOW_OPEN_TABLES,
    SQLCOM_HA_OPEN, SQLCOM_HA_CLOSE, SQLCOM_HA_READ,
    SQLCOM_SHOW_SLAVE_HOSTS, SQLCOM_DELETE_MULTI, SQLCOM_UPDATE_MULTI,
    SQLCOM_SHOW_BINLOG_EVENTS, SQLCOM_DO,
    SQLCOM_SHOW_WARNS, SQLCOM_EMPTY_QUERY, SQLCOM_SHOW_ERRORS,
    SQLCOM_SHOW_STORAGE_ENGINES, SQLCOM_SHOW_PRIVILEGES,
    SQLCOM_HELP, SQLCOM_CREATE_USER, SQLCOM_DROP_USER, SQLCOM_RENAME_USER,
    SQLCOM_REVOKE_ALL, SQLCOM_CHECKSUM,
    SQLCOM_CREATE_PROCEDURE, SQLCOM_CREATE_SPFUNCTION, SQLCOM_CALL,
    SQLCOM_DROP_PROCEDURE, SQLCOM_ALTER_PROCEDURE,SQLCOM_ALTER_FUNCTION,
    SQLCOM_SHOW_CREATE_PROC, SQLCOM_SHOW_CREATE_FUNC,
    SQLCOM_SHOW_STATUS_PROC, SQLCOM_SHOW_STATUS_FUNC,
    SQLCOM_PREPARE, SQLCOM_EXECUTE, SQLCOM_DEALLOCATE_PREPARE,
    SQLCOM_CREATE_VIEW, SQLCOM_DROP_VIEW,
    SQLCOM_CREATE_TRIGGER, SQLCOM_DROP_TRIGGER,
    SQLCOM_XA_START, SQLCOM_XA_END, SQLCOM_XA_PREPARE,
    SQLCOM_XA_COMMIT, SQLCOM_XA_ROLLBACK, SQLCOM_XA_RECOVER,
    SQLCOM_SHOW_PROC_CODE, SQLCOM_SHOW_FUNC_CODE,
    SQLCOM_ALTER_TABLESPACE,
    SQLCOM_INSTALL_PLUGIN, SQLCOM_UNINSTALL_PLUGIN,
    SQLCOM_SHOW_AUTHORS, SQLCOM_BINLOG_BASE64_EVENT,
    SQLCOM_SHOW_PLUGINS, SQLCOM_SHOW_CONTRIBUTORS,
    SQLCOM_CREATE_SERVER, SQLCOM_DROP_SERVER, SQLCOM_ALTER_SERVER,
    SQLCOM_CREATE_EVENT, SQLCOM_ALTER_EVENT, SQLCOM_DROP_EVENT,
    SQLCOM_SHOW_CREATE_EVENT, SQLCOM_SHOW_EVENTS,
    SQLCOM_SHOW_CREATE_TRIGGER,
    SQLCOM_ALTER_DB_UPGRADE,
    SQLCOM_SHOW_PROFILE, SQLCOM_SHOW_PROFILES,
    SQLCOM_SIGNAL, SQLCOM_RESIGNAL,
    SQLCOM_SHOW_RELAYLOG_EVENTS,
    SQLCOM_GET_DIAGNOSTICS,
    SQLCOM_SLAVE_ALL_START, SQLCOM_SLAVE_ALL_STOP,
    SQLCOM_SHOW_EXPLAIN, SQLCOM_SHUTDOWN,
    SQLCOM_CREATE_ROLE, SQLCOM_DROP_ROLE, SQLCOM_GRANT_ROLE, SQLCOM_REVOKE_ROLE,
    SQLCOM_COMPOUND,
    SQLCOM_SHOW_GENERIC,
    SQLCOM_ALTER_USER,
    SQLCOM_SHOW_CREATE_USER,
    SQLCOM_EXECUTE_IMMEDIATE,
    SQLCOM_CREATE_SEQUENCE,
    SQLCOM_DROP_SEQUENCE,
    SQLCOM_ALTER_SEQUENCE,
    SQLCOM_CREATE_PACKAGE,
    SQLCOM_DROP_PACKAGE,
    SQLCOM_CREATE_PACKAGE_BODY,
    SQLCOM_DROP_PACKAGE_BODY,
    SQLCOM_SHOW_CREATE_PACKAGE,
    SQLCOM_SHOW_CREATE_PACKAGE_BODY,
    SQLCOM_SHOW_STATUS_PACKAGE,
    SQLCOM_SHOW_STATUS_PACKAGE_BODY,
    SQLCOM_SHOW_PACKAGE_BODY_CODE,
    
    /*
      When a command is added here, be sure it's also added in mysqld.cc
      in "struct show_var_st com_status_vars[]= {" ...
    */
    /* This should be the last !!! */
    SQLCOM_END
};

#define STATE_BACKUP_DATABASE "STATE_LOG_BACKUP_DB"
#define STATE_CHANGE_DATABASE "STATE_LOG_CHANGE_DB"
#define STATE_TRIGGER_DATABASE "STATE_TRIGGER_DB"
#define STATE_GROUP_DATABASE "STATE_GROUP_DB"

#define STATE_GROUP_TABLE "STATE_GROUP_TABLE"

#define STATE_ALTER_COMMENT_STRING "FOR STATE METADATA LOCK"
#define STATE_QUERY_COMMENT_STRING "/* GENERATED BY STATE QUERY */"
#define STATE_GROUP_COMMENT_STRING "/* GENERATED BY STATE GROUP */"

#define STATE_HASH_EVENT_KEY 30015
#define STATE_HASH_EVENT_MSG_TYPE 1
#define STATE_HASH_EVENT_MAX_SIZE 4
struct state_hash_event
{
  long msgtyp;
  char table[STATE_HASH_EVENT_MAX_SIZE];
};


//상태 변환에서 사용하는 에러 번호 목록
//ER_ERROR_LAST 보다 커야 함
#define ER_STATE_START 5000
#define ER_STATE_TEMP_TABLE (ER_STATE_START + 1)
#define ER_STATE_VIEW_TABLE (ER_STATE_START + 2)
#define ER_STATE_VIEW_RENAME (ER_STATE_START + 3)
#define ER_STATE_TABLE_RENAME (ER_STATE_START + 4)
#define ER_STATE_TRUNC_VIEW (ER_STATE_START + 5)
#define ER_STATE_CREATE_ACL (ER_STATE_START + 6)
#define ER_STATE_CREATE_DB (ER_STATE_START + 7)
#define ER_STATE_OPEN_TABLE (ER_STATE_START + 8)
#define ER_STATE_ALTER_TABLE (ER_STATE_START + 9)
#define ER_STATE_CLONE_OPEN (ER_STATE_START + 10)
#define ER_STATE_CLONE_PREPARE (ER_STATE_START + 11)
#define ER_STATE_CLONE_FIX (ER_STATE_START + 12)
#define ER_STATE_CLONE_CREATE (ER_STATE_START + 13)
#define ER_STATE_CLONE_EXISTS (ER_STATE_START + 14)

struct state_log_time
{
  long sec;
  uint32_t sec_part;

  state_log_time() : sec(0), sec_part(0) {}
  state_log_time(long sec, uint32_t sec_part) : sec(sec), sec_part(sec_part) {}

  state_log_time &operator++()
  {
    if (sec_part == 999999)
    {
      ++sec;
      sec_part = 0;
    }
    else
    {
      ++sec_part;
    }
    return *this;
  }

  state_log_time &operator--()
  {
    if (sec_part == 0)
    {
      --sec;
      sec_part = 999999;
    }
    else
    {
      --sec_part;
    }
    return *this;
  }

  bool operator==(const struct state_log_time &rhs) const
  {
    return (sec == rhs.sec && sec_part == rhs.sec_part);
  }
  bool operator<(const struct state_log_time &rhs) const
  {
    if (sec < rhs.sec)
      return true;
    else if (sec == rhs.sec && sec_part < rhs.sec_part)
      return true;
    else
      return false;
  }
  bool operator<=(const struct state_log_time &rhs) const
  {
    if (sec < rhs.sec)
      return true;
    else if (sec == rhs.sec && sec_part <= rhs.sec_part)
      return true;
    else
      return false;
  }
  bool operator>(const struct state_log_time &rhs) const
  {
    if (sec > rhs.sec)
      return true;
    else if (sec == rhs.sec && sec_part > rhs.sec_part)
      return true;
    else
      return false;
  }
  bool operator>=(const struct state_log_time &rhs) const
  {
    if (sec > rhs.sec)
      return true;
    else if (sec == rhs.sec && sec_part >= rhs.sec_part)
      return true;
    else
      return false;
  }
};

enum en_state_log_foreign_key_type : uint8_t
{
  en_foreign_key_none = 0,
  en_foreign_key_add,
  en_foreign_key_drop,
};

enum en_state_log_table_access_type : uint8_t
{
  en_table_access_read = 0,
  en_table_access_write,
};

enum en_state_log_foreign_key_opt_type : uint8_t
{
  en_foreign_key_opt_none = 0,
  en_foreign_key_opt_check,
};

struct state_log_hdr_foreign
{
  state_log_hdr_foreign() : table_type(en_foreign_key_none),
                            update_type(en_foreign_key_opt_none),
                            delete_type(en_foreign_key_opt_none),
                            access_type(en_table_access_read),
                            foreign_name_length(0),
                            foreign_table_length(0),
                            columns_length(0),
                            foreign_columns_length(0)
  {
  }

  state_log_hdr_foreign(
      en_state_log_foreign_key_type _table_type,
      en_state_log_foreign_key_opt_type _update_type,
      en_state_log_foreign_key_opt_type _delete_type,
      en_state_log_table_access_type _access_type)
      : table_type(_table_type),
        update_type(_update_type),
        delete_type(_delete_type),
        access_type(_access_type),
        foreign_name_length(0),
        foreign_table_length(0),
        columns_length(0),
        foreign_columns_length(0)
  {
  }
  en_state_log_foreign_key_type table_type;
  en_state_log_foreign_key_opt_type update_type;
  en_state_log_foreign_key_opt_type delete_type;
  en_state_log_table_access_type access_type;
  uint16_t foreign_name_length;
  uint16_t foreign_table_length;
  uint16_t columns_length;
  uint16_t foreign_columns_length;
};

struct state_log_hdr
{
  state_log_time start_time;
  uint64_t xid;

  uint8_t is_user_query;
  uint8_t foreign_count;
  uint8_t data_column_count;
  uint8_t where_column_count;
  uint16_t sql_command;
  uint16_t query_length;

  uint16_t read_table_length;
  uint16_t write_table_length;

  uint32_t foreign_length;
  uint32_t data_column_item_length;
  uint32_t where_column_item_length;
};

enum en_state_log_column_item_type : uint16_t
{
  en_column_item_none  = (uint16_t)-1, 
  en_column_item_field = 0,  // Item::FIELD_ITEM
  en_column_item_func  = 1,  // Item::FUNC_ITEM
  en_column_item_cond  = 13, // Item::COND_ITEM

  //내부적으로만 사용
  en_column_item_int   = 5,  // Item::INT_ITEM
  en_column_item_date  = 29, // Item::DATE_ITEM
  en_column_item_real  = 6,  // Item::REAL_ITEM
  en_column_item_deci  = 24, // Item::DECIMAL_ITEM
  en_column_item_str   = 4,  // Item::STRING_ITEM
  en_column_item_nul   = 7,  // Item::NULL_ITEM

};

// item_type 이 field 일때 sub_type 은 해당 내용 사용
enum en_state_log_column_data_type : uint16_t
{
  en_column_data_null = 0,
  en_column_data_int = 1,
  en_column_data_uint = 2,
  en_column_data_double = 3,
  en_column_data_string = 4,
  en_column_data_decimal = 5,
  en_column_data_from_subselect = 0x80,
};
inline en_state_log_column_data_type &operator|=(en_state_log_column_data_type &lhs, en_state_log_column_data_type rhs)
{
  lhs = (en_state_log_column_data_type)(lhs | rhs);
  return lhs;
}

// item_type 이 func 일때 sub_type 은 해당 내용 사용
enum en_state_log_column_func_type : uint16_t
{
  en_column_func_eq = 1,       // Item_func::EQ_FUNC
  en_column_func_equal = 2,    // Item_func::EQUAL_FUNC
  en_column_func_ne = 3,       // Item_func::NE_FUNC
  en_column_func_lt = 4,       // Item_func::LT_FUNC
  en_column_func_le = 5,       // Item_func::LE_FUNC
  en_column_func_gt = 7,       // Item_func::GT_FUNC
  en_column_func_ge = 6,       // Item_func::GE_FUNC
  en_column_func_between = 15, // Item_func::BETWEEN
};

// item_type 이 cond 일때 sub_type 은 해당 내용 사용
enum en_state_log_column_cond_type : uint16_t
{
  en_column_cond_and = 12, // Item_func::COND_AND_FUNC
  en_column_cond_or = 13,  // Item_func::COND_OR_FUNC
};

struct state_log_column_item
{
  state_log_column_item() : item_type(en_column_item_none),
                            arg_count(0),
                            data_length(0),
                            data(NULL)
  {
  }

  en_state_log_column_item_type item_type;
  union _sub_type {
    _sub_type()
    {
      memset(this, 0, sizeof(sub_type));
    }
    en_state_log_column_data_type data;
    en_state_log_column_func_type func;
    en_state_log_column_cond_type cond;
  } sub_type;
  // uint16_t func_type; //en_state_log_column_data_type
  uint16_t arg_count;
  uint16_t data_length;
  unsigned char *data;
  std::vector<unsigned char> data_array;
};
static const int state_log_column_item_length = sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint16_t);

enum en_state_hash_table_from : uint32_t
{
  en_from_backup_table = 1,
  en_from_origin_table
};
struct st_state_hash_create_table
{
  en_state_hash_table_from from;
  uint32_t from_sec;
  uint32_t from_sec_part;
  size_t length;
  //char name[n]
};

struct st_state_hash_write_table
{
  size_t length;
  //char name[n]
};

struct st_state_hash_check
{
  uint32_t target_query_sec;
  uint32_t target_query_sec_part;

  size_t create_table_count;
  //struct st_state_hash_create_table[n]

  size_t write_table_count;
  //struct st_state_hash_write_table[n]
};

struct st_state_group
{
  uint64_t group_id;
  uint64_t trx_id;
  uint32_t time_sec;
  uint32_t time_usec;
};

#endif /* STATE_LOG_HDR_INCLUDED */
